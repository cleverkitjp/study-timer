<!DOCTYPE html>
<html lang="ja">
<head>
  <!-- Google Analytics GA4 -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-F6517NYNFF"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-F6517NYNFF');
  </script>

  <!-- AdSense -->
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9727255179923866"
       crossorigin="anonymous"></script>

  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <title>勉強用ポモドーロタイマー｜なぜか集中できる25分タイマー</title>
  <meta name="description" content="勉強に集中できるポモドーロタイマー（25分集中→5分休憩）。登録不要・無料・スマホ最適化。ワンタップで開始、4セットごと長休憩15分にも対応。勉強時間ログ（今日・今週・月別）も自動保存。" />

  <meta property="og:type" content="website" />
  <meta property="og:title" content="勉強用ポモドーロタイマー｜なぜか集中できる25分タイマー" />
  <meta property="og:description" content="ポモドーロ（25分集中→5分休憩）で勉強が進む。登録不要・無料・スマホ最適化。長休憩15分、ログ（今日/今週/月別）も自動保存。" />

  <link rel="stylesheet" href="https://cleverkitjp.github.io/common.css">

  <style>
    :root { color-scheme: light dark; }
    body { -webkit-tap-highlight-color: transparent; }

    .wrap { max-width: 820px; margin: 0 auto; padding: 14px 12px 32px; }
    .hero { margin-top: 10px; }
    .sub2 { margin-top: 6px; color: var(--text-sub); }

    .timer-shell {
      margin-top: 12px;
      background: #161616;
      border-radius: 18px;
      padding: 12px;
      border: 1px solid rgba(255,255,255,0.06);
    }
    .timer-face { display: grid; gap: 12px; }
    .timer-core {
      background: var(--card);
      border-radius: 16px;
      padding: 14px;
      border: 1px solid var(--border);
      display: grid;
      gap: 12px;
    }

    .phase-pill {
      display: inline-flex; align-items: center; gap: 8px;
      padding: 8px 12px; border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(127,127,127,0.06);
      width: fit-content;
      font-weight: 700;
    }
    .phase-dot { width: 10px; height: 10px; border-radius: 999px; background: currentColor; opacity: 0.8; }
    .phase-meta { color: var(--text-sub); font-size: 12px; margin-top: 2px; }

    .time {
      font-variant-numeric: tabular-nums;
      font-weight: 900;
      letter-spacing: 0.02em;
      line-height: 1;
      font-size: clamp(46px, 12vw, 72px);
      text-align: center;
      padding: 20px 0 12px;
      margin: 12px 0;
    }

    .btn-row { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .btn-row .btn { width: 100%; }

    .btn {
      display: inline-flex; justify-content: center; align-items: center;
      gap: 8px;
      border: 1px solid var(--border);
      background: var(--card);
      color: var(--text);
      padding: 12px 14px;
      border-radius: 14px;
      font-weight: 800;
      cursor: pointer;
      user-select: none;
    }
    .btn:active { transform: translateY(1px); }
    .btn.primary {
      border-color: transparent;
      background: var(--accent, #2563eb);
      color: white;
    }
    .btn.ghost { background: transparent; }
    .btn.small { padding: 10px 12px; font-weight: 800; border-radius: 12px; font-size: 13px; }

    .row { display: grid; gap: 10px; }
    .grid2 { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .muted { color: var(--text-sub); font-size: 12px; }
    .hr { height: 1px; background: var(--border); margin: 10px 0; }

    details { border: 1px solid var(--border); border-radius: 14px; background: var(--card); padding: 10px 12px; }
    details + details { margin-top: 10px; }
    summary { cursor: pointer; font-weight: 900; }
    summary::-webkit-details-marker { display: none; }

    .controls { display: grid; gap: 10px; margin-top: 6px; }
    .outside-card-area { display: grid; gap: 10px; margin-top: 10px; }
    #hintLine { margin-bottom: 16px; }
    .chip-row { display: flex; gap: 8px; flex-wrap: wrap; }
    .chip {
      border: 1px solid var(--border);
      border-radius: 999px;
      padding: 8px 10px;
      font-weight: 800;
      font-size: 12px;
      background: rgba(127,127,127,0.06);
      cursor: pointer;
      user-select: none;
    }
    .chip[aria-pressed="true"] {
      background: rgba(37,99,235,0.14);
      border-color: rgba(37,99,235,0.35);
    }

    .log-kpis { display: grid; grid-template-columns: 1fr; gap: 6px; margin-top: 8px; }
    .kpi { display: flex; justify-content: space-between; gap: 10px; font-variant-numeric: tabular-nums; }
    .kpi b { font-weight: 900; }
    .log-list { margin: 10px 0 8px; padding-left: 18px; color: var(--text-sub); }
    .log-actions { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 8px; }
    .danger { border-color: rgba(220,38,38,0.35); color: rgb(220,38,38); }

    .toast {
      position: fixed; left: 50%; bottom: 16px; transform: translateX(-50%);
      max-width: 92vw;
      background: rgba(0,0,0,0.78);
      color: #fff;
      padding: 10px 12px;
      border-radius: 999px;
      font-size: 13px;
      opacity: 0;
      pointer-events: none;
      transition: opacity .18s ease;
      z-index: 9999;
    }
    .toast.show { opacity: 1; }

    @media (min-width: 560px) {
      .btn-row { grid-template-columns: 1fr 1fr 1fr; }
      .btn-row .btn.primary { grid-column: span 2; }
    }
/* ===== タイトルを控えめにする ===== */
.hero h1 {
  font-size: 1.5rem;   /* ← 少し小さめ */
  line-height: 1.4;
  margin-bottom: 6px;
}

    body.is-running .hero,
    body.is-running details:not(#logDetails),
    body.is-running .outside-card {
      opacity: 0.35;
    }
    body.is-running #logDetails {
      opacity: 0.4;
    }
    body.is-running #timeDisplay,
    body.is-running #phasePill,
    body.is-running #phaseLabel,
    body.is-running #phaseMeta,
    body.is-running #startPauseBtn,
    body.is-running #skipRestBtn {
      opacity: 1;
    }
    body:not(.is-running) #logDetails summary {
      opacity: 1;
      font-weight: 900;
    }
  </style>

  <script type="application/ld+json">
  {
    "@context":"https://schema.org",
    "@type":"FAQPage",
    "mainEntity":[
      {"@type":"Question","name":"ポモドーロテクニックは何分が基本？","acceptedAnswer":{"@type":"Answer","text":"一般的には「25分集中→5分休憩」をくり返し、4セットごとに長休憩を入れる形がよく使われます。"}},
      {"@type":"Question","name":"25分がきついときは？","acceptedAnswer":{"@type":"Answer","text":"最初は短め（例：20分）にしても続けやすいことがあります。無理のない範囲で調整してください。"}},
      {"@type":"Question","name":"スマホで画面を消しても動く？","acceptedAnswer":{"@type":"Answer","text":"基本的に動作します。環境により通知の出方は異なるため、復帰時に完了状態を表示します。"}}
    ]
  }
  </script>
</head>

<body>
  <main class="wrap">
    <header class="hero">
      <h1>勉強用ポモドーロタイマー</h1>
      <p class="sub2">ポモドーロテクニックとは、「25分集中 → 5分休憩」をくり返す、シンプルな集中法です。<br></p>
    </header>

    <section class="timer-shell" aria-label="タイマー">
      <div class="timer-face">
        <div class="timer-core" role="group" aria-label="集中・休憩カード">
          <div>
            <div class="phase-pill" id="phasePill" aria-live="polite">
              <span class="phase-dot" aria-hidden="true"></span>
              <span id="phaseLabel">集中</span>
            </div>
            <div class="phase-meta" id="phaseMeta">セット 1 / 4（長休憩まで）</div>
          </div>

          <div class="time" id="timeDisplay">25:00</div>

          <div class="btn-row" role="group" aria-label="操作">
            <button class="btn primary" id="startPauseBtn">開始</button>
            <button class="btn ghost" id="resetBtn">リセット</button>
            <button class="btn small" id="skipRestBtn" style="display:none;">休憩をスキップ</button>
          </div>
        </div>
      </div>
    </section>

    <section class="outside-card-area outside-card" aria-label="目標セットとオプション">
      <div class="muted" id="hintLine">すぐ開始できます（設定は最小限）。</div>

      <div class="controls">
        <div class="grid2">
          <div>
            <div class="muted">目標セット</div>
            <div class="chip-row" role="group" aria-label="目標セット">
              <button class="chip" data-goal="0" aria-pressed="true">目標なし</button><br>
              <button class="chip" data-goal="4" aria-pressed="false">4セット</button><br>
              <button class="chip" data-goal="8" aria-pressed="false">8セット</button><br>
              <button class="chip" data-goal="12" aria-pressed="false">12セット</button>
            </div>
          </div>
          <div>
            <div class="muted">オプション</div>
            <div class="row">
              <label class="chip" style="display:flex; align-items:center; justify-content:space-between; gap:10px;">
                <span>長休憩（4セットごと15分）</span>
                <input id="longBreakToggle" type="checkbox" checked />
              </label>
              <label class="chip" style="display:flex; align-items:center; justify-content:space-between; gap:10px;">
                <span>画面を点けたまま（対応端末）</span>
                <input id="wakeLockToggle" type="checkbox" />
              </label>
            </div>
          </div>
        </div>

        <div class="hr"></div>
      </div>
    </section>

    <section class="row" aria-label="補足情報">
      <details>
        <summary>なぜポモドーロテクニックは効果が高いのか</summary>
        <div class="muted" style="margin-top:8px; line-height:1.7;">
          ポモドーロテクニックが効果的だと言われる理由は、人間の「集中力の限界」と「脳の回復メカニズム」に合っているからです。<br>
          一般に、強い集中を保てる時間は20〜30分程度とされており、それ以上続けると集中力は低下しやすくなります。短い休憩をはさむことで、次の集中に入りやすくなります。<br>
          また「終わりが見える時間設定」は先延ばしやダラダラ作業を防ぎやすいとされています。特別な道具や才能が不要で、今日からすぐ始められる点も、広く使われている理由のひとつです。
        </div>
      </details>

      <details id="logDetails">
        <summary>ログ</summary>

        <div class="log-kpis" aria-label="ログ集計" style="margin-top:10px;">
          <div class="kpi"><span>今日</span><b id="kpiToday">0.0時間</b></div>
          <div class="kpi"><span>今週</span><b id="kpiThisWeek">0.0時間</b></div>
          <div class="kpi"><span>先週</span><b id="kpiLastWeek">0.0時間</b></div>
        </div>

        <ol class="log-list" id="monthList" aria-label="月別ログ"></ol>

        <div class="log-actions" aria-label="ログ操作">
          <button class="btn" id="copyLogBtn">ログをコピー</button>
          <button class="btn ghost danger" id="resetLogBtn">ログをリセット</button>
        </div>

        <div class="muted" style="margin-top:10px; line-height:1.6;">
          ※ログはこの端末のブラウザにのみ保存されます。<br>
          ※機種変更・ブラウザ変更・データ削除で消えます。
        </div>
      </details>

      <details>
        <summary>よくある質問</summary>
        <div class="muted" style="margin-top:8px; line-height:1.7;">
          <b>Q. 基本は何分？</b><br>
          A. 一般的には「25分集中→5分休憩」、4セットごとに長休憩を入れる形がよく使われます。<br><br>
          <b>Q. 休憩を飛ばしてもいい？</b><br>
          A. 原則は休憩も含めて1セットですが、状況により休憩を飛ばしたいこともあります。疲れが残りやすい場合は休憩をおすすめします。<br><br>
          <b>Q. 画面を消しても動く？</b><br>
          A. 基本的に動作します。通知の出方は端末・ブラウザで異なるため、復帰時に完了状態を表示します。
        </div>
      </details>
    </section>
  </main>

  <div class="toast" id="toast" role="status" aria-live="polite"></div>

  <!-- footer.html loader (required) -->
  <div id="ck-footer-container"></div>
  <script>
    (function() {
      var container = document.getElementById('ck-footer-container');
      if (!container) return;

      fetch('https://cleverkitjp.github.io/footer.html')
        .then(function(response) { return response.text(); })
        .then(function(html) {
          container.innerHTML = html;

          try { (adsbygoogle = window.adsbygoogle || []).push({}); }
          catch (e) { console.warn('adsbygoogle error', e); }
        })
        .catch(function(e) { console.warn('footer load error', e); });
    })();
  </script>

  <script>
    (function(){
      "use strict";
      var PHASE_FOCUS = "focus";
      var PHASE_REST = "rest";
      var PHASE_LONG = "long";

      var DEFAULT_FOCUS_SEC = 25 * 60;
      var DEFAULT_REST_SEC  = 5 * 60;
      var DEFAULT_LONG_SEC  = 15 * 60;

      var LONG_BREAK_EVERY = 4;
      var LS_KEY = "ck_pomodoro_v1";
      var LS_LOG_KEY = "ck_pomodoro_log_v1"; // { "YYYY-MM-DD": secondsFocused }

      var state = {
        phase: PHASE_FOCUS,
        running: false,
        endAt: 0,
        remainingSec: DEFAULT_FOCUS_SEC,
        focusCount: 0,
        goalSets: 0,
        longBreakEnabled: true,
        wakeLockEnabled: false,
        wakeLock: null,
        audioArmed: false
      };

      var timeDisplay = document.getElementById("timeDisplay");
      var phaseLabel  = document.getElementById("phaseLabel");
      var phaseMeta   = document.getElementById("phaseMeta");
      var hintLine    = document.getElementById("hintLine");

      var startPauseBtn = document.getElementById("startPauseBtn");
      var resetBtn      = document.getElementById("resetBtn");
      var skipRestBtn   = document.getElementById("skipRestBtn");

      var longBreakToggle = document.getElementById("longBreakToggle");
      var wakeLockToggle  = document.getElementById("wakeLockToggle");

      var toastEl = document.getElementById("toast");

      var kpiToday = document.getElementById("kpiToday");
      var kpiThisWeek = document.getElementById("kpiThisWeek");
      var kpiLastWeek = document.getElementById("kpiLastWeek");
      var monthList = document.getElementById("monthList");

      var copyLogBtn = document.getElementById("copyLogBtn");
      var resetLogBtn = document.getElementById("resetLogBtn");

      function pad2(n){ return (n < 10 ? "0" : "") + n; }
      function formatMMSS(sec){
        var m = Math.floor(sec / 60);
        var s = Math.max(0, sec % 60);
        return pad2(m) + ":" + pad2(s);
      }
      function nowMs(){ return Date.now(); }

      function showToast(msg){
        toastEl.textContent = msg;
        toastEl.classList.add("show");
        clearTimeout(showToast._t);
        showToast._t = setTimeout(function(){ toastEl.classList.remove("show"); }, 1600);
      }

      function clamp(n, min, max){ return Math.max(min, Math.min(max, n)); }

      function getLocalISODate(d){
        var y = d.getFullYear();
        var m = pad2(d.getMonth() + 1);
        var day = pad2(d.getDate());
        return y + "-" + m + "-" + day;
      }

      function weekStartISO(d){
        var dd = new Date(d.getFullYear(), d.getMonth(), d.getDate());
        var day = dd.getDay(); // 0 Sun ... 6 Sat
        var diff = (day === 0 ? -6 : 1 - day); // to Monday
        dd.setDate(dd.getDate() + diff);
        dd.setHours(0,0,0,0);
        return dd;
      }

      function toHours1(sec){
        var hours = sec / 3600;
        return (Math.round(hours * 10) / 10).toFixed(1);
      }

      function safeJSONParse(s, fallback){
        try { return JSON.parse(s); } catch(e){ return fallback; }
      }

      function loadState(){
        var raw = localStorage.getItem(LS_KEY);
        if (!raw) return;
        var data = safeJSONParse(raw, null);
        if (!data) return;

        state.goalSets = (typeof data.goalSets === "number") ? data.goalSets : 0;
        state.longBreakEnabled = (typeof data.longBreakEnabled === "boolean") ? data.longBreakEnabled : true;

        if (data && data.timer && typeof data.timer === "object") {
          var t = data.timer;
          if (t.phase) state.phase = t.phase;
          if (typeof t.focusCount === "number") state.focusCount = t.focusCount;

          if (typeof t.endAt === "number" && typeof t.running === "boolean") {
            state.running = t.running;
            state.endAt = t.endAt;
            if (!state.running && typeof t.remainingSec === "number") {
              state.remainingSec = t.remainingSec;
            }
          }
        }

        if (state.running && state.endAt > 0) {
          var rem = Math.ceil((state.endAt - nowMs()) / 1000);
          if (rem <= 0) {
            state.running = false;
            state.remainingSec = 0;
          } else {
            state.remainingSec = rem;
          }
        }
      }

      function saveState(){
        var payload = {
          goalSets: state.goalSets,
          longBreakEnabled: state.longBreakEnabled,
          timer: {
            phase: state.phase,
            running: state.running,
            endAt: state.endAt,
            remainingSec: state.remainingSec,
            focusCount: state.focusCount
          }
        };
        localStorage.setItem(LS_KEY, JSON.stringify(payload));
      }

      function loadLog(){
        var raw = localStorage.getItem(LS_LOG_KEY);
        var obj = raw ? safeJSONParse(raw, {}) : {};
        if (!obj || typeof obj !== "object") obj = {};
        return obj;
      }

      function saveLog(obj){
        localStorage.setItem(LS_LOG_KEY, JSON.stringify(obj));
      }

      function addFocusToLog(seconds){
        if (seconds <= 0) return;
        var log = loadLog();
        var key = getLocalISODate(new Date());
        log[key] = (log[key] || 0) + seconds;
        saveLog(log);
        renderLog();
      }

      function sumLogBetween(log, startDate, endDateExclusive){
        var total = 0;
        var d = new Date(startDate.getTime());
        while (d < endDateExclusive) {
          var key = getLocalISODate(d);
          total += (log[key] || 0);
          d.setDate(d.getDate() + 1);
        }
        return total;
      }

      function getMonthKey(d){
        return d.getFullYear() + "-" + pad2(d.getMonth() + 1);
      }

      function renderLog(){
        var log = loadLog();

        var today = new Date();
        today.setHours(0,0,0,0);
        var tomorrow = new Date(today.getTime()); tomorrow.setDate(tomorrow.getDate() + 1);
        var todaySec = sumLogBetween(log, today, tomorrow);

        var ws = weekStartISO(new Date());
        var wsNext = new Date(ws.getTime()); wsNext.setDate(wsNext.getDate() + 7);
        var lastWs = new Date(ws.getTime()); lastWs.setDate(lastWs.getDate() - 7);

        var thisWeekSec = sumLogBetween(log, ws, wsNext);
        var lastWeekSec = sumLogBetween(log, lastWs, ws);  // ★ここが切れていた行です

        kpiToday.textContent = toHours1(todaySec) + "時間";
        kpiThisWeek.textContent = toHours1(thisWeekSec) + "時間";
        kpiLastWeek.textContent = toHours1(lastWeekSec) + "時間";

        monthList.innerHTML = "";
        var months = {};
        Object.keys(log).forEach(function(dateKey){
          if (!/^\d{4}-\d{2}-\d{2}$/.test(dateKey)) return;
          var mkey = dateKey.slice(0,7);
          months[mkey] = (months[mkey] || 0) + (log[dateKey] || 0);
        });

        var hasAny = Object.keys(months).length > 0;
        if (!hasAny) {
          var li0 = document.createElement("li");
          li0.textContent = "まだログがありません（集中が完了すると自動で記録されます）";
          monthList.appendChild(li0);
          return;
        }

        var d = new Date();
        d.setDate(1); d.setHours(0,0,0,0);
        var keys = [];
        for (var i=0; i<12; i++){
          keys.push(getMonthKey(d));
          d.setMonth(d.getMonth() - 1);
        }

        keys.forEach(function(k){
          if (!months[k]) return;
          var y = k.slice(0,4);
          var m = k.slice(5,7);
          var li = document.createElement("li");
          li.textContent = y + "年" + parseInt(m,10) + "月　" + toHours1(months[k]) + "時間";
          monthList.appendChild(li);
        });
      }

      function buildCopyText(){
        var log = loadLog();

        var today = new Date(); today.setHours(0,0,0,0);
        var tomorrow = new Date(today.getTime()); tomorrow.setDate(tomorrow.getDate() + 1);

        var ws = weekStartISO(new Date());
        var wsNext = new Date(ws.getTime()); wsNext.setDate(wsNext.getDate() + 7);
        var lastWs = new Date(ws.getTime()); lastWs.setDate(lastWs.getDate() - 7);

        var todaySec = sumLogBetween(log, today, tomorrow);
        var thisWeekSec = sumLogBetween(log, ws, wsNext);
        var lastWeekSec = sumLogBetween(log, lastWs, ws);

        var months = {};
        Object.keys(log).forEach(function(dateKey){
          if (!/^\d{4}-\d{2}-\d{2}$/.test(dateKey)) return;
          var mkey = dateKey.slice(0,7);
          months[mkey] = (months[mkey] || 0) + (log[dateKey] || 0);
        });

        var lines = [];
        lines.push("【勉強ログ】");
        lines.push("今日：" + toHours1(todaySec) + "時間");
        lines.push("今週：" + toHours1(thisWeekSec) + "時間");
        lines.push("先週：" + toHours1(lastWeekSec) + "時間");
        lines.push("");

        if (Object.keys(months).length === 0) {
          lines.push("（まだログがありません）");
          return lines.join("\n");
        }

        var d = new Date();
        d.setDate(1); d.setHours(0,0,0,0);
        for (var i=0; i<12; i++){
          var key = getMonthKey(d);
          if (months[key]) {
            var y = key.slice(0,4);
            var m = key.slice(5,7);
            lines.push(y + "年" + parseInt(m,10) + "月　" + toHours1(months[key]) + "時間");
          }
          d.setMonth(d.getMonth() - 1);
        }
        return lines.join("\n");
      }

      async function copyText(text){
        try {
          await navigator.clipboard.writeText(text);
          showToast("コピーしました");
          return true;
        } catch (e) {
          try {
            var ta = document.createElement("textarea");
            ta.value = text;
            ta.setAttribute("readonly", "");
            ta.style.position = "fixed";
            ta.style.left = "-9999px";
            document.body.appendChild(ta);
            ta.select();
            document.execCommand("copy");
            document.body.removeChild(ta);
            showToast("コピーしました");
            return true;
          } catch (e2) {
            showToast("コピーできませんでした");
            return false;
          }
        }
      }
      var audioCtx = null;
      function armAudio(){
        if (state.audioArmed) return;
        state.audioArmed = true;
        try {
          audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          if (audioCtx && audioCtx.state === "suspended") audioCtx.resume();
        } catch(e){ audioCtx = null; }
      }

      function beep(){
        try {
          if (!audioCtx) return;
          var o = audioCtx.createOscillator();
          var g = audioCtx.createGain();
          o.connect(g); g.connect(audioCtx.destination);
          o.type = "sine";
          o.frequency.value = 880;
          g.gain.value = 0.0001;
          var t0 = audioCtx.currentTime;
          g.gain.exponentialRampToValueAtTime(0.2, t0 + 0.01);
          g.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.25);
          o.start(t0);
          o.stop(t0 + 0.28);
        } catch(e){}
      }

      function vibrate(){
        try { if (navigator.vibrate) navigator.vibrate([120, 60, 120]); } catch(e){}
      }

      async function notifyDone(message){
        beep();
        vibrate();
        try {
          if ("Notification" in window && Notification.permission === "granted") {
            new Notification("ポモドーロタイマー", { body: message });
          }
        } catch(e){}
      }

      async function setWakeLock(enabled){
        state.wakeLockEnabled = enabled;
        if (!("wakeLock" in navigator)) {
          if (enabled) showToast("この端末では未対応です");
          return;
        }
        try {
          if (enabled) {
            state.wakeLock = await navigator.wakeLock.request("screen");
            state.wakeLock.addEventListener("release", function(){ state.wakeLock = null; });
            showToast("画面スリープ抑止：ON");
          } else {
            if (state.wakeLock) await state.wakeLock.release();
            state.wakeLock = null;
            showToast("画面スリープ抑止：OFF");
          }
        } catch(e) {
          state.wakeLockEnabled = false;
          wakeLockToggle.checked = false;
          showToast("設定できませんでした");
        }
      }

      document.addEventListener("visibilitychange", function(){
        if (document.visibilityState === "visible" && state.wakeLockEnabled && wakeLockToggle.checked) {
          setWakeLock(true);
        }
        syncRemainingFromEndAt();
        render();
      });

      function phaseDurationSec(phase){
        if (phase === PHASE_FOCUS) return DEFAULT_FOCUS_SEC;
        if (phase === PHASE_REST) return DEFAULT_REST_SEC;
        return DEFAULT_LONG_SEC;
      }

      function phaseName(phase){
        if (phase === PHASE_FOCUS) return "集中";
        if (phase === PHASE_REST) return "休憩";
        return "長休憩";
      }

      function syncRemainingFromEndAt(){
        if (!state.running) return;
        var rem = Math.ceil((state.endAt - nowMs()) / 1000);
        state.remainingSec = clamp(rem, 0, 24*60*60);
      }

      function pause(){
        syncRemainingFromEndAt();
        state.running = false;
        state.endAt = 0;
        saveState();
        render();
      }

      function resetTimer(confirmFirst){
        var doReset = function(){
          state.running = false;
          state.endAt = 0;
          state.phase = PHASE_FOCUS;
          state.remainingSec = DEFAULT_FOCUS_SEC;
          state.focusCount = 0;
          saveState();
          render();
          showToast("リセットしました");
        };
        if (confirmFirst) {
          if (confirm("タイマーをリセットしますか？")) doReset();
        } else {
          doReset();
        }
      }

      function goNextPhase(){
        var prev = state.phase;

        if (prev === PHASE_FOCUS) {
          addFocusToLog(DEFAULT_FOCUS_SEC);
          state.focusCount += 1;

          if (state.goalSets > 0 && state.focusCount >= state.goalSets) {
            state.phase = PHASE_FOCUS;
            state.remainingSec = DEFAULT_FOCUS_SEC;
            state.running = false;
            state.endAt = 0;
            saveState();
            render();
            notifyDone("目標セット完了。ここまでおつかれさま。");
            showToast("目標セット完了");
            return;
          }

          if (state.longBreakEnabled && (state.focusCount % LONG_BREAK_EVERY === 0)) {
            state.phase = PHASE_LONG;
            state.remainingSec = DEFAULT_LONG_SEC;
            notifyDone("4セット完了。少し長めに休もう。");
          } else {
            state.phase = PHASE_REST;
            state.remainingSec = DEFAULT_REST_SEC;
            notifyDone("25分おつかれさま。5分休憩しよう。");
          }
        } else {
          state.phase = PHASE_FOCUS;
          state.remainingSec = DEFAULT_FOCUS_SEC;
          notifyDone("休憩おわり。次の25分、いこう。");
        }

        if (state.running) state.endAt = nowMs() + state.remainingSec * 1000;
        else state.endAt = 0;

        saveState();
        render();
      }

      function tick(){
        if (!state.running) return;
        syncRemainingFromEndAt();

        if (state.remainingSec <= 0) {
          state.remainingSec = 0;
          goNextPhase();
          return;
        }
        renderTimeOnly();
      }

      function renderTimeOnly(){
        timeDisplay.textContent = formatMMSS(state.remainingSec);
      }

      function render(){
        if (state.running) syncRemainingFromEndAt();

        phaseLabel.textContent = phaseName(state.phase);

        var inCycle = (state.focusCount % LONG_BREAK_EVERY) + 1;
        var metaText = state.longBreakEnabled
          ? ("セット " + inCycle + " / " + LONG_BREAK_EVERY + "（長休憩まで）")
          : ("セット " + state.focusCount);
        phaseMeta.textContent = metaText;

        renderTimeOnly();

        startPauseBtn.textContent = state.running
          ? "一時停止"
          : ((state.remainingSec === phaseDurationSec(state.phase)) ? "開始" : "再開");

        var isRest = (state.phase === PHASE_REST || state.phase === PHASE_LONG);
        skipRestBtn.style.display = isRest ? "inline-flex" : "none";

        hintLine.textContent = isRest
          ? "休憩はスキップできますが、集中力を保つには短い休憩がおすすめです。軽く体を伸ばすだけでも効果があります。"
          : "集中が完了するとログに自動記録されます。";

        longBreakToggle.checked = !!state.longBreakEnabled;

        document.body.classList.toggle("is-running", state.running);

        saveState();
      }

      startPauseBtn.addEventListener("click", function(){
        armAudio();

        if (state.running) {
          pause();
          showToast("一時停止");
        } else {
          state.running = true;
          if (state.remainingSec <= 0) state.remainingSec = phaseDurationSec(state.phase);
          state.endAt = nowMs() + state.remainingSec * 1000;
          saveState();
          render();
          showToast("開始");
        }
      });

      resetBtn.addEventListener("click", function(){
        resetTimer(true);
      });

      skipRestBtn.addEventListener("click", function(){
        if (!(state.phase === PHASE_REST || state.phase === PHASE_LONG)) return;
        state.phase = PHASE_FOCUS;
        state.remainingSec = DEFAULT_FOCUS_SEC;
        if (state.running) state.endAt = nowMs() + state.remainingSec * 1000;
        saveState();
        render();
        showToast("休憩をスキップ");
      });

      longBreakToggle.addEventListener("change", function(){
        state.longBreakEnabled = !!longBreakToggle.checked;
        saveState();
        render();
      });

      wakeLockToggle.addEventListener("change", function(){
        setWakeLock(!!wakeLockToggle.checked);
      });

      Array.prototype.slice.call(document.querySelectorAll(".chip[data-goal]")).forEach(function(btn){
        btn.addEventListener("click", function(){
          var goal = parseInt(btn.getAttribute("data-goal"), 10) || 0;
          state.goalSets = goal;
          Array.prototype.slice.call(document.querySelectorAll(".chip[data-goal]")).forEach(function(b){
            b.setAttribute("aria-pressed", (b === btn) ? "true" : "false");
          });
          saveState();
          showToast(goal === 0 ? "目標なし" : ("目標：" + goal + "セット"));
        });
      });

      copyLogBtn.addEventListener("click", function(){
        copyText(buildCopyText());
      });

      resetLogBtn.addEventListener("click", function(){
        if (!confirm("これまでの勉強ログをすべて削除します。元に戻せません。")) return;
        localStorage.removeItem(LS_LOG_KEY);
        renderLog();
        showToast("ログをリセットしました");
      });

      loadState();

      (function(){
        var goal = state.goalSets || 0;
        Array.prototype.slice.call(document.querySelectorAll(".chip[data-goal]")).forEach(function(b){
          var g = parseInt(b.getAttribute("data-goal"), 10) || 0;
          b.setAttribute("aria-pressed", (g === goal) ? "true" : "false");
        });
        longBreakToggle.checked = !!state.longBreakEnabled;
      })();

      if (state.remainingSec <= 0) state.remainingSec = phaseDurationSec(state.phase);

      renderLog();
      render();

      setInterval(tick, 250);
    })();
  </script>
</body>
</html>
<!-- PART 3/3：ここまで -->
